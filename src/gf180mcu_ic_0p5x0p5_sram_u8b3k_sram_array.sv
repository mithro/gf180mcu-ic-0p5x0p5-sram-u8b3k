// SPDX-FileCopyrightText: Â© 2025 SRAM Forge Contributors
// SPDX-License-Identifier: Apache-2.0
// Generated by sram-forge
// Chip: gf180mcu_ic_0p5x0p5_sram_u8b3k
// GF180MCU 0.5x0.5 SRAM Test Chip - 3KB unified 8-bit bus
// Configuration:
//   SRAM Macro: gf180mcu_fd_ip_sram__sram512x8m8wm1
//   Total SRAMs: 6
//   Total Words: 3072
//   Address Bits: 12
//   Data Width: 8
//   Output Routing: mux

`default_nettype none

module gf180mcu_ic_0p5x0p5_sram_u8b3k_sram_array (
    `ifdef USE_POWER_PINS
    // Power supplies (directly connected to SRAM macros)
    inout  wire                    VDD,
    inout  wire                    VSS,
    `endif
    // Functional signals
    input  wire                    clk,
    input  wire                    rst_n,
    input  wire                    ce_n,      // Chip enable (active low)
    input  wire                    we_n,      // Write enable (active low)
    input  wire [11:0]       addr,      // Address bus
    input  wire [7:0]        din,       // Data input
    output wire [7:0]        dout       // Data output
);

    // Address decoding
    // Upper bits select SRAM, lower bits address within SRAM
    wire [2:0] sram_sel;
    wire [8:0] sram_addr;

    assign sram_sel = addr[11:9];
    assign sram_addr = addr[8:0];

    // SRAM enable signals (directly from address decoder)
    wire [5:0] sram_ce_n;
    assign sram_ce_n[0] = ce_n | (sram_sel != 3'd0);
    assign sram_ce_n[1] = ce_n | (sram_sel != 3'd1);
    assign sram_ce_n[2] = ce_n | (sram_sel != 3'd2);
    assign sram_ce_n[3] = ce_n | (sram_sel != 3'd3);
    assign sram_ce_n[4] = ce_n | (sram_sel != 3'd4);
    assign sram_ce_n[5] = ce_n | (sram_sel != 3'd5);

    // SRAM output buses
    wire [7:0] sram_dout_0;
    wire [7:0] sram_dout_1;
    wire [7:0] sram_dout_2;
    wire [7:0] sram_dout_3;
    wire [7:0] sram_dout_4;
    wire [7:0] sram_dout_5;

    // SRAM macro instantiations
    gf180mcu_fd_ip_sram__sram512x8m8wm1 sram_0 (
        `ifdef USE_POWER_PINS
        .VDD(VDD),
        .VSS(VSS),
        `endif
        .CLK(clk),
        .CEN(sram_ce_n[0]),
        .GWEN(we_n),
        .WEN(8'b0),  // All bits written when GWEN active
        .A(sram_addr),
        .D(din),
        .Q(sram_dout_0)
    );

    gf180mcu_fd_ip_sram__sram512x8m8wm1 sram_1 (
        `ifdef USE_POWER_PINS
        .VDD(VDD),
        .VSS(VSS),
        `endif
        .CLK(clk),
        .CEN(sram_ce_n[1]),
        .GWEN(we_n),
        .WEN(8'b0),  // All bits written when GWEN active
        .A(sram_addr),
        .D(din),
        .Q(sram_dout_1)
    );

    gf180mcu_fd_ip_sram__sram512x8m8wm1 sram_2 (
        `ifdef USE_POWER_PINS
        .VDD(VDD),
        .VSS(VSS),
        `endif
        .CLK(clk),
        .CEN(sram_ce_n[2]),
        .GWEN(we_n),
        .WEN(8'b0),  // All bits written when GWEN active
        .A(sram_addr),
        .D(din),
        .Q(sram_dout_2)
    );

    gf180mcu_fd_ip_sram__sram512x8m8wm1 sram_3 (
        `ifdef USE_POWER_PINS
        .VDD(VDD),
        .VSS(VSS),
        `endif
        .CLK(clk),
        .CEN(sram_ce_n[3]),
        .GWEN(we_n),
        .WEN(8'b0),  // All bits written when GWEN active
        .A(sram_addr),
        .D(din),
        .Q(sram_dout_3)
    );

    gf180mcu_fd_ip_sram__sram512x8m8wm1 sram_4 (
        `ifdef USE_POWER_PINS
        .VDD(VDD),
        .VSS(VSS),
        `endif
        .CLK(clk),
        .CEN(sram_ce_n[4]),
        .GWEN(we_n),
        .WEN(8'b0),  // All bits written when GWEN active
        .A(sram_addr),
        .D(din),
        .Q(sram_dout_4)
    );

    gf180mcu_fd_ip_sram__sram512x8m8wm1 sram_5 (
        `ifdef USE_POWER_PINS
        .VDD(VDD),
        .VSS(VSS),
        `endif
        .CLK(clk),
        .CEN(sram_ce_n[5]),
        .GWEN(we_n),
        .WEN(8'b0),  // All bits written when GWEN active
        .A(sram_addr),
        .D(din),
        .Q(sram_dout_5)
    );

    // Output multiplexer
    reg [7:0] dout_mux;

    always @(*) begin
        case (sram_sel)
            3'd0: dout_mux = sram_dout_0;
            3'd1: dout_mux = sram_dout_1;
            3'd2: dout_mux = sram_dout_2;
            3'd3: dout_mux = sram_dout_3;
            3'd4: dout_mux = sram_dout_4;
            3'd5: dout_mux = sram_dout_5;
            default: dout_mux = 8'h0;
        endcase
    end

    assign dout = dout_mux;

endmodule

`default_nettype wire